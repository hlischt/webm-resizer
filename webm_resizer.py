import json
import random
import sys
import pathlib
import subprocess
import tempfile
import datetime
import shutil
import argparse
import functions


def ffprobe(path: pathlib.Path) -> dict:
    '''Call ffprobe to retrieve path's video stream information.

    Returns the JSON output generated by ffprobe, parsed as a dict.'''
    try:
        ffprobe_out = subprocess.run([
            'ffprobe',
            '-v', 'error',
            '-print_format', 'json',
            '-show_streams',
            '-select_streams', 'v:0',
            str(path),
        ], capture_output=True, check=True)
    except subprocess.CalledProcessError as e:
        raise ChildProcessError(e.stderr.decode()) from e
    return json.loads(ffprobe_out.stdout.decode())


def vid_info(path: pathlib.Path) -> dict:
    '''Get the resolution and framerate from the video stored at path.'''
    vid_json = ffprobe(path)['streams'][0]
    return {
        'res': (vid_json['width'], vid_json['height']),
        'fps': vid_json['avg_frame_rate'],
    }


def ffmpeg_dump_frames(infile: pathlib.Path, outseq: pathlib.Path,
                       fps: str):
    '''Call ffmpeg to dump a sequence of frames in outdir.

    outseq is a pathlib object with a name like "./%03d.png".'''
    if not infile.exists():
        raise FileNotFoundError(f'{str(infile)} does not exist')
    if infile.is_dir():
        raise IsADirectoryError(f'{str(infile)} is a directory')
    if not outseq.parent.exists() or not outseq.parent.is_dir():
        raise NotADirectoryError(f'{str(outseq.parent)} is not a directory')
    try:
        subprocess.run([
            'ffmpeg', '-hide_banner', '-i',
            str(infile),
            '-an', '-sn', '-dn', '-vf', f'fps={fps}',
            str(outseq),
        ], capture_output=True, check=True)
    except subprocess.CalledProcessError as e:
        raise ChildProcessError('ffmpeg returned an error') from e


def ffmpeg_img2webm(infile: pathlib.Path, res: tuple, fps: str,
                    iteration: int, h_func, v_func):
    try:
        subprocess.run([
            'ffmpeg', '-hide_banner',
            '-r', fps,
            '-i', str(infile),
            '-an', '-sn', '-dn', '-vf',
            f'scale={h_func(iteration, res[0])}:'
            + f'{v_func(iteration, res[1])}'
            + ':flags=lanczos,setsar=1/1,'
            + f'fps={fps}',
            '-vcodec', 'libvpx-vp9',
            str(infile.with_suffix('.webm')),
        ], capture_output=True, check=True)
    except subprocess.CalledProcessError as e:
        raise ChildProcessError('ffmpeg returned an error') from e


def quote_file(path: pathlib.Path) -> str:
    '''Returns a quoted path, with escaped single quotes.'''
    return "'" + str(path.resolve()).replace("'", r"'\''") + "'"


def ffmpeg_concat(vid_list: pathlib.Path, orig_vid: pathlib.Path,
                  output_vid: pathlib.Path):
    try:
        subprocess.run([
            'ffmpeg', '-hide_banner', '-f', 'concat',
            '-safe', '0',
            '-i', str(vid_list),
            '-i', str(orig_vid),
            '-map', '0:v', '-map', '1:a?',
            '-vcodec', 'copy',
            '-acodec', 'libopus', '-b:a', '96k',
            '-map_metadata', '-1',
            str(output_vid),
        ], check=True)
    except subprocess.CalledProcessError as e:
        raise ChildProcessError('ffmpeg returned an error') from e


def check_ff():
    probe = shutil.which('ffprobe') is None
    mpeg = shutil.which('ffmpeg') is None
    names = []
    if probe:
        names.append('ffprobe')
    if mpeg:
        names.append('ffmpeg')
    if len(names) > 0:
        sys.exit(f'Error: {" and ".join(names)} not found')


def check_infile(inpath: str,
                 outpath) -> tuple[pathlib.Path, pathlib.Path]:
    vid_path = pathlib.Path(inpath)
    if not vid_path.is_file():
        sys.exit(f'Error: {str(vid_path)} is not a valid file')
    if outpath is None:
        out = vid_path.with_suffix('.out.webm')
    else:
        out = pathlib.Path(outpath)
    if out == vid_path or not out.parent.is_dir():
        sys.exit(f"Error: Can't write to {str(out)}")
    return vid_path, out


def process_video(vid_path: pathlib.Path, out_path: pathlib.Path,
                  temp_dir: str, h_name, v_name) -> None:
    print(f'Getting resolution/framerate from {vid_path}...', file=sys.stderr)
    temp = pathlib.Path(temp_dir)
    vinfo = vid_info(vid_path)
    print(f'Creating PNG sequence as {temp / "%05d.png"}...', file=sys.stderr)
    ffmpeg_dump_frames(vid_path, temp / '%05d.png', vinfo['fps'])
    pngs = sorted(temp.glob('./*.png'))
    webms = []
    concat_list = ''
    print('Converting PNG images to webm...', file=sys.stderr)
    png_n = len(pngs)
    h_func = functions.init_func(h_name, png_n)
    v_func = functions.init_func(v_name, png_n)
    for idx, i in enumerate(pngs):
        print('\r\033[0K', end='', file=sys.stderr, flush=True)
        print(f'Processing frame {idx+1} of {png_n}', end='',
              file=sys.stderr, flush=True)
        ffmpeg_img2webm(i, vinfo['res'], vinfo['fps'],
                        idx, h_func, v_func)
        i.unlink()
        concat_list += f'file {quote_file(i.with_suffix(".webm"))}\n'
        webms.append(i.with_suffix('.webm'))
    print('', file=sys.stderr)
    with open(temp / 'list.txt', 'w', encoding='utf-8') as f:
        f.write(concat_list)
    ffmpeg_concat(temp / 'list.txt', vid_path, out_path)
    print('Deleting temporary files...', file=sys.stderr)
    for i in webms:
        i.unlink()


def parse_args():
    parser = argparse.ArgumentParser(
        description='Create a WebM video with a dynamic resolution.',
        epilog='Available functions: ' + ', '.join(functions.func_dict)
    )
    parser.add_argument('-x', '--horizontal', metavar='FUNCTION',
                        default='shrink',
                        help='Function to apply to the horizontal axis.')
    parser.add_argument('-y', '--vertical', metavar='FUNCTION',
                        default='shrink',
                        help='Function to apply to the vertical axis.')
    parser.add_argument('input_file', help='Video to convert.')
    parser.add_argument('output_file', nargs='?',
                        default=None,
                        help='Path to the new video file.')
    return parser.parse_args()


def main():
    args = parse_args()
    if args.horizontal not in functions.func_dict:
        sys.exit(f'Error: {args.horizontal} is not a defined function')
    if args.vertical not in functions.func_dict:
        sys.exit(f'Error: {args.vertical} is not a defined function')
    h_func, v_func = args.horizontal, args.vertical
    random.seed(datetime.datetime.now().timestamp())
    check_ff()
    vid_path, out_path = check_infile(args.input_file, args.output_file)
    print(f'vid_path = {vid_path}, out_path = {out_path}')
    with tempfile.TemporaryDirectory() as td:
        process_video(vid_path, out_path, td, h_func, v_func)
    print(f'Successfully encoded {out_path}',
          file=sys.stderr)


if __name__ == '__main__':
    main()
